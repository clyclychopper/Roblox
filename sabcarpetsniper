-- ══════════════════════════════════════════════
--               TOGGLE GUI
-- ══════════════════════════════════════════════

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

if playerGui:FindFirstChild("AutoBuyerGUI") then
    playerGui.AutoBuyerGUI:Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoBuyerGUI"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 220, 0, 110)
mainFrame.Position = UDim2.new(0, 16, 0, 16)
mainFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 14)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 28)
mainCorner.Parent = mainFrame

local stroke = Instance.new("UIStroke")
stroke.Color = Color3.fromRGB(80, 220, 120)
stroke.Thickness = 1.5
stroke.Transparency = 0.3
stroke.Parent = mainFrame

local dot = Instance.new("Frame")
dot.Size = UDim2.new(0, 10, 0, 10)
dot.Position = UDim2.new(0, 18, 0.5, -5)
dot.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
dot.BorderSizePixel = 0
dot.Parent = mainFrame

local dotCorner = Instance.new("UICorner")
dotCorner.CornerRadius = UDim.new(1, 0)
dotCorner.Parent = dot

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, -100, 1, 0)
label.Position = UDim2.new(0, 36, 0, 0)
label.BackgroundTransparency = 1
label.Text = "Brainrot Sniper -Cly"
label.Font = Enum.Font.GothamBold
label.TextSize = 13
label.TextColor3 = Color3.fromRGB(220, 220, 220)
label.TextXAlignment = Enum.TextXAlignment.Left
label.Parent = mainFrame

local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(0, 36, 1, 0)
statusLabel.Position = UDim2.new(1, -96, 0, 0)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "OFF"
statusLabel.Font = Enum.Font.GothamBold
statusLabel.TextSize = 11
statusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
statusLabel.TextXAlignment = Enum.TextXAlignment.Right
statusLabel.Parent = mainFrame

local toggleBg = Instance.new("Frame")
toggleBg.Size = UDim2.new(0, 46, 0, 26)
toggleBg.Position = UDim2.new(1, -62, 0.5, -13)
toggleBg.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
toggleBg.BorderSizePixel = 0
toggleBg.Parent = mainFrame

local toggleBgCorner = Instance.new("UICorner")
toggleBgCorner.CornerRadius = UDim.new(1, 0)
toggleBgCorner.Parent = toggleBg

local knob = Instance.new("Frame")
knob.Size = UDim2.new(0, 20, 0, 20)
knob.Position = UDim2.new(0, 3, 0.5, -10)
knob.BackgroundColor3 = Color3.fromRGB(120, 120, 130)
knob.BorderSizePixel = 0
knob.Parent = toggleBg

local knobCorner = Instance.new("UICorner")
knobCorner.CornerRadius = UDim.new(1, 0)
knobCorner.Parent = knob

local shine = Instance.new("Frame")
shine.Size = UDim2.new(0, 6, 0, 6)
shine.Position = UDim2.new(0, 4, 0, 3)
shine.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
shine.BackgroundTransparency = 0.6
shine.BorderSizePixel = 0
shine.Parent = knob

local shineCorner = Instance.new("UICorner")
shineCorner.CornerRadius = UDim.new(1, 0)
shineCorner.Parent = shine

-- Server Hop Button
local hopButton = Instance.new("TextButton")
hopButton.Size = UDim2.new(1, -32, 0, 36)
hopButton.Position = UDim2.new(0, 16, 1, -52)
hopButton.BackgroundColor3 = Color3.fromRGB(50, 130, 200)
hopButton.BorderSizePixel = 0
hopButton.Text = "Server Hop"
hopButton.Font = Enum.Font.GothamBold
hopButton.TextSize = 12
hopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
hopButton.Parent = mainFrame

local hopButtonCorner = Instance.new("UICorner")
hopButtonCorner.CornerRadius = UDim.new(0, 10)
hopButtonCorner.Parent = hopButton

local hopButtonStroke = Instance.new("UIStroke")
hopButtonStroke.Color = Color3.fromRGB(70, 150, 220)
hopButtonStroke.Thickness = 1
hopButtonStroke.Transparency = 0.5
hopButtonStroke.Parent = hopButton

-- ═══════════════ TOGGLE LOGIC ═══════════════

local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

local function updateVisuals(enabled)
    if enabled then
        TweenService:Create(knob, tweenInfo, {
            Position = UDim2.new(0, 23, 0.5, -10),
            BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        }):Play()
        TweenService:Create(toggleBg, tweenInfo, {
            BackgroundColor3 = Color3.fromRGB(50, 210, 100)
        }):Play()
        TweenService:Create(dot, tweenInfo, {
            BackgroundColor3 = Color3.fromRGB(50, 230, 100)
        }):Play()
        TweenService:Create(stroke, tweenInfo, {
            Color = Color3.fromRGB(50, 210, 100),
            Transparency = 0.1
        }):Play()
        statusLabel.Text = "ON"
        statusLabel.TextColor3 = Color3.fromRGB(50, 210, 100)
    else
        TweenService:Create(knob, tweenInfo, {
            Position = UDim2.new(0, 3, 0.5, -10),
            BackgroundColor3 = Color3.fromRGB(120, 120, 130)
        }):Play()
        TweenService:Create(toggleBg, tweenInfo, {
            BackgroundColor3 = Color3.fromRGB(35, 35, 40)
        }):Play()
        TweenService:Create(dot, tweenInfo, {
            BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        }):Play()
        TweenService:Create(stroke, tweenInfo, {
            Color = Color3.fromRGB(80, 80, 100),
            Transparency = 0.5
        }):Play()
        statusLabel.Text = "OFF"
        statusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
    end
end

toggleBg.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        getgenv().AutoBuyerEnabled = not getgenv().AutoBuyerEnabled
        updateVisuals(getgenv().AutoBuyerEnabled)
        print("[AutoBuyer] Toggled:", getgenv().AutoBuyerEnabled and "ON" or "OFF")
    end
end)

updateVisuals(getgenv().AutoBuyerEnabled)

-- ═══════════════ SERVER HOP LOGIC ═══════════════

local function serverHop()
    local placeId = game.PlaceId
    local currentJobId = game.JobId
    
    hopButton.Text = "Finding..."
    hopButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    
    task.spawn(function()
        local success, result = pcall(function()
            local servers = {}
            local cursor = ""
            
            for i = 1, 3 do
                local url = string.format(
                    "https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100&cursor=%s",
                    placeId,
                    cursor
                )
                
                local response = game:HttpGet(url)
                local data = HttpService:JSONDecode(response)
                
                if data and data.data then
                    for _, server in ipairs(data.data) do
                        if server.id ~= currentJobId and server.playing < server.maxPlayers then
                            table.insert(servers, server.id)
                        end
                    end
                end
                
                cursor = data.nextPageCursor or ""
                if cursor == "" then break end
            end
            
            if #servers == 0 then
                hopButton.Text = "No Servers"
                hopButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                wait(2)
                hopButton.Text = "Server Hop"
                hopButton.BackgroundColor3 = Color3.fromRGB(50, 130, 200)
                return
            end
            
            local randomServer = servers[math.random(1, #servers)]
            
            print("[ServerHop] Teleporting to server:", randomServer)
            hopButton.Text = "Hopping..."
            
            TeleportService:TeleportToPlaceInstance(placeId, randomServer, player)
        end)
        
        if not success then
            warn("[ServerHop] Error:", result)
            hopButton.Text = "Failed"
            hopButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
            wait(2)
            hopButton.Text = "Server Hop"
            hopButton.BackgroundColor3 = Color3.fromRGB(50, 130, 200)
        end
    end)
end

hopButton.MouseButton1Click:Connect(function()
    serverHop()
end)

-- ══════════════════════════════════════════════
--               AUTOBUYER LOGIC
-- ══════════════════════════════════════════════

local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

-- FIX 1: Increased fire distance to be more forgiving
local FIRE_DISTANCE = 8
local DEBOUNCE = 3
local REFIRE_COOLDOWN = 5
local lastFired = 0
local isBusy = false

local renderedFolder = workspace:WaitForChild("RenderedMovingAnimals")
local recentlyFired = {}
local foundTargets = false

-- ANTI AFK
spawn(function()
    while true do
        wait(60)
        pcall(function() player:Move(Vector3.new(0, 0, 0), true) end)
    end
end)

player.Idled:Connect(function()
    pcall(function() player:Move(Vector3.new(0, 0, 0), true) end)
end)

local function cleanRecentlyFired()
    local now = tick()
    for prompt, firedAt in pairs(recentlyFired) do
        if now - firedAt > REFIRE_COOLDOWN then
            recentlyFired[prompt] = nil
        end
    end
end

-- FIX 2: Robust name extraction — trims all whitespace and price tags
local function extractAnimalName(objectText)
    -- Handles formats like "Cat $25K", "Big Dog$100K", "Rare Fox  $1M"
    local name = objectText:match("^(.-)%s*%$") or objectText
    return name:match("^%s*(.-)%s*$") -- trim leading/trailing whitespace
end

local function getPromptPart(prompt)
    local p = prompt.Parent
    if p:IsA("Attachment") then p = p.Parent end
    if p:IsA("BasePart") then return p end
    return nil
end

local function isAnimalRendered(targetName)
    for _, child in ipairs(renderedFolder:GetChildren()) do
        if child.Name:lower() == targetName:lower() then
            return true
        end
    end
    return false
end

-- FIX 3: Collect ALL matching prompts across workspace, pick closest
local function findAllMatchingPrompts(targetName)
    local results = {}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") and obj.ActionText == "Purchase" then
            local promptName = extractAnimalName(obj.ObjectText)
            if promptName:lower() == targetName:lower() then
                local part = getPromptPart(obj)
                if part and part.Parent then
                    local dist = (rootPart.Position - part.Position).Magnitude
                    table.insert(results, {prompt = obj, part = part, dist = dist})
                end
            end
        end
    end
    -- Sort by distance ascending
    table.sort(results, function(a, b) return a.dist < b.dist end)
    return results
end

local function findClosestPrompt()
    cleanRecentlyFired()

    local targetNames = getgenv().targetNames or {}

    if not foundTargets then
        print("[AutoBuyer] TARGET NAMES LOADED:")
        for i, name in ipairs(targetNames) do
            print(string.format("  %d. '%s'", i, name))
        end
        foundTargets = true
    end

    local closestPrompt, closestPart, closestDist, closestMatchedName = nil, nil, math.huge, nil

    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") and obj.ActionText == "Purchase" then
            local promptName = extractAnimalName(obj.ObjectText)

            -- FIX 4: Print every found Purchase prompt so you can debug name mismatches
            -- Uncomment the line below temporarily to see all prompts:
            -- print("[DEBUG] Found prompt: '" .. promptName .. "'")

            local isTarget = false
            for _, targetName in ipairs(targetNames) do
                if promptName:lower():find(targetName:lower(), 1, true) then
                    isTarget = true
                    break
                end
            end

            -- FIX 5: Check rendered folder with exact name match (was doing .find before which could false-positive)
            local isRendered = false
            for _, child in ipairs(renderedFolder:GetChildren()) do
                if child.Name:lower() == promptName:lower() then
                    isRendered = true
                    break
                end
            end

            if isTarget and isRendered and not recentlyFired[obj] then
                local part = getPromptPart(obj)
                if part then
                    local dist = (rootPart.Position - part.Position).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closestPrompt = obj
                        closestPart = part
                        closestMatchedName = promptName
                    end
                end
            end
        end
    end

    if closestPrompt then
        print(string.format("[AutoBuyer] Found target: '%s' | Dist: %.2f", closestMatchedName, closestDist))
    else
        print("[AutoBuyer] No valid targets found this cycle.")
    end

    return closestPrompt, closestPart, closestDist, closestMatchedName
end

local function findAndFire()
    if isBusy then return end
    local now = tick()
    if now - lastFired < DEBOUNCE then return end

    local prompt, part, dist, matchedName = findClosestPrompt()
    if not prompt or not part then return end

    isBusy = true
    print(string.format("[AutoBuyer] Locking onto: '%s' | Starting dist: %.2f", matchedName, dist))
    recentlyFired[prompt] = tick()

    local lockedName = matchedName
    local fired = false
    local timeout = tick() + 15

    while tick() < timeout do
        -- Check animal is still rendered
        if not isAnimalRendered(lockedName) then
            print("[AutoBuyer] Animal '" .. lockedName .. "' no longer rendered, aborting.")
            break
        end

        -- FIX 6: Always re-find the closest prompt each tick (animal moves)
        local prompts = findAllMatchingPrompts(lockedName)

        if #prompts == 0 then
            print("[AutoBuyer] No prompts found for '" .. lockedName .. "', aborting.")
            break
        end

        -- Pick the closest one that isn't on cooldown (or any if all are)
        local best = nil
        for _, entry in ipairs(prompts) do
            if not recentlyFired[entry.prompt] then
                best = entry
                break
            end
        end
        if not best then best = prompts[1] end

        local currentDist = best.dist
        print(string.format("[AutoBuyer] Moving to '%s' | Dist: %.2f", lockedName, currentDist))

        -- FIX 7: Move toward the prompt's part position
        humanoid:MoveTo(best.part.Position)

        if currentDist <= FIRE_DISTANCE then
            print(string.format("[AutoBuyer] Within range! Dist: %.2f — attempting fire...", currentDist))
            task.wait(0.1)

            -- Re-check distance after brief wait
            local finalPart = getPromptPart(best.prompt)
            local finalDist = finalPart and (rootPart.Position - finalPart.Position).Magnitude or math.huge

            -- FIX 8: Use the prompt's own MaxActivationDistance as the cap, not just our hardcoded value
            local maxDist = math.max(FIRE_DISTANCE, best.prompt.MaxActivationDistance)

            print(string.format("[AutoBuyer] Final dist: %.2f | MaxActivationDistance: %.2f", finalDist, best.prompt.MaxActivationDistance))

            if best.prompt and best.prompt.Parent and finalDist <= maxDist then
                print("[AutoBuyer] ✓ FIRING PROMPT for: " .. lockedName)
                fireproximityprompt(best.prompt)
                lastFired = tick()
                recentlyFired[best.prompt] = tick()
                fired = true
                print("[AutoBuyer] Successfully fired! Cooldown started.")
            else
                print(string.format("[AutoBuyer] ✗ NOT FIRING — dist %.2f > max %.2f", finalDist, maxDist))
            end
            break
        end

        task.wait(0.1)
    end

    if not fired then
        print("[AutoBuyer] Did not fire for: " .. lockedName .. " (timeout or aborted)")
        -- FIX 9: Clear cooldown so it can retry immediately if it failed to fire
        for k, _ in pairs(recentlyFired) do
            local kPart = getPromptPart(k)
            if kPart then
                local name = extractAnimalName(k.ObjectText or "")
                if name:lower() == lockedName:lower() then
                    recentlyFired[k] = nil
                end
            end
        end
    end

    isBusy = false
    print("[AutoBuyer] Cycle complete. isBusy reset.")
end

player.CharacterAdded:Connect(function(char)
    character = char
    rootPart = char:WaitForChild("HumanoidRootPart")
    humanoid = char:WaitForChild("Humanoid")
    isBusy = false
    lastFired = 0
    recentlyFired = {}
    foundTargets = false
    print("[AutoBuyer] Character respawned, state reset.")
end)

task.spawn(function()
    while true do
        task.wait(0.5)
        if getgenv().AutoBuyerEnabled then
            findAndFire()
        end
    end
end)

print("[AutoBuyer] Loaded! Use the toggle button to enable.")
